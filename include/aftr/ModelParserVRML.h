//----------------------------------------------------------------------------
//Author: Scott Nykl
//----------------------------------------------------------------------------

#pragma once

#include "ModelParser.h"
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include "AftrGlobals.h"
#include "Vector.h"


namespace Aftr
{

class ModelDataShared;
class Model;
class ModelParserVRMLShape;
class ModelParserVRMLFace;
class BoundingBox;
struct VertexListEntry;

class ModelParserVRML : public ModelParser
{
public:
   //-------------------------------------------------------------------------
   //Constructor that instantiates a new Model.  For the Model Object to 
   //contain useful data, the user must call initFromVRML() and pass in the
   //path to a VRML file generated by Q3BSP.EXE
   //param: textures - the texture handler for the game 
   //-------------------------------------------------------------------------
   ModelParserVRML( const std::string& fileName, const Vector& scale, const MESH_SHADING_TYPE& shadingType );

   //-------------------------------------------------------------------------
   //Destructor that deletes and NULL-ifys all pointers owned by this 
   //instance.
   //-------------------------------------------------------------------------
   virtual ~ModelParserVRML( );

   virtual ModelDataShared* parse();
  

   //-------------------------------------------------------------------------
   //This method uses the data collected from the BoundingBox to compute the
   //"center point" of the Model.  This is the point around which scalings and
   //rotations shall occur.
   //-------------------------------------------------------------------------
   void calculateFixedPointFromBBox();

   void setShadingSmooth();

   bool getUsingSmoothShading() { return this->useSmoothShading; }


protected:

   std::vector< int >* getOriginalIndexList();
   std::vector< Vector* >* getOriginalVertexList();

   //-------------------------------------------------------------------------
   //Called by initFromFile only if this Model is not already
   //loaded into memory
   //-------------------------------------------------------------------------
   bool initFromVRML( const std::string& fileName, const Vector& scale );

   //-------------------------------------------------------------------------
   //This method actually begins parsing the VRML file and instantiates all
   //ModelParserVRMLShape Objects composing this Model object.
   //sr: pointer to the input file stream. This must be checked
   //for NULL prior to calling this method.
   //-------------------------------------------------------------------------
   void readModelFromFile( std::ifstream* sr, const Vector& scale );

   //-------------------------------------------------------------------------
   //This method creates the composite Vertex list of all the verticies within
   //the entire Model File of this model. The corresponding composite Index
   //list of all the indicies into the Vertex list is also created.
   //-------------------------------------------------------------------------
   void createCompositeVertexAndIndexLists();

   //-------------------------------------------------------------------------
   //This method returns true if Vector v is already in the 
   //std::vector< Vector* >* compositeVertexList; false otherwise.
   //-------------------------------------------------------------------------
   bool alreadyInCompositeVertexList( Vector* v );

   //-------------------------------------------------------------------------
   //The following chunk of variables are managed by the ManagerModelMultiplicity ----
   std::vector< ModelParserVRMLShape* >* shapes;  //stores all ModelShapes of this Model

   std::vector< Vector* >* compositeVertexList; //all verticies within this entire model
   std::vector< int >* compositeIndexList;      //all indicies into the compositeVertexList

   BoundingBox* bBox;      //Axis aligned bounding box based off min and max Verticies read from file
   Vector fixedPoint;      //scalings and rotations are w.r.t this point (computed based on bBox)
   bool useSmoothShading;
   MESH_SHADING_TYPE shadingType;

   //Added for Vertex Listing
   void createVertexLists();
   std::vector<int> makeTextureVerticesUnique();
   GLvoid* indexList;
   VertexListEntry* vertexList;

};

} //namespace Aftr

